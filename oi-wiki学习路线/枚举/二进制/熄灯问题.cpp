// https://www.mfstem.org/p/764
//每次修改会变化，问怎么动才能把所有点改成同一个状态
#include<iostream>
using namespace std;
int a[9][9], btn[9][9];	//a：灯初始状态, btn：灯按下状态，1表示按下，0未按下
int main()
{
	for(int i=1; i<=5; ++i)
		for(int j=1; j<=6; ++j) cin>>a[i][j];
	for(int k=0; k<64; ++k) //枚举第一行灯的按下状态 000000~111111，对应的整数为0~63
    {
		for(int j=1; j<=6; ++j)
            btn[1][j]=(k>>(j-1))&1; //将枚举的第一行状态存入数组第一行（取出第j位）
		for(int i=2; i<=5; ++i)	//依次计算2~5行每一个灯的按下状态
			for(int j=1; j<=6; ++j)
                btn[i][j]=a[i-1][j]^btn[i-1][j-1]^btn[i-1][j]^btn[i-1][j+1]^btn[i-2][j];
		int j;
		for(j=1; j<=6; ++j)	//最后一行灯按下后是什么状态
			if((a[5][j]^btn[4][j]^btn[5][j-1]^btn[5][j]^btn[5][j+1])==1) //1表示灯亮
                break; //说明枚举的k状态不合适，验证下一个值
		if(j>6)
        { //最后一行灯都灭，说明k正确，按下信息btn合适，输出结果
			for(int i=1; i<=5; ++i)
            {
				for(int j=1; j<=6; ++j) cout<<btn[i][j]<<" ";
				cout<<endl;
			}
			return 0;
		}
	}
	return 0;
}
/*
在原本亮着的灯的周围以及它本身的五个按钮有奇数个按钮被按下可以将其熄灭
同理，在原本就熄灭的灯的周围以及它本身的五个按钮中有偶数个按钮被按下则不会改变其自身的状态
所以，只要确定了第一行所有按钮按/不按的状态，随后其余行的按钮状态都可以根据其对应上一行的灯的状态以及其周围的按钮状态推出来（其实也就是间接确定了）
综上只需要枚举出第一行按钮的所有状态一一比对即可。
*/